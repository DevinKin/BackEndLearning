# 第一章-可靠性、可扩展性、可维护性

如今很多应用程序都是数据密集型（data-intensive），而不是计算密集型（compute-intensive）。因此CPU很少成为这类应用的瓶颈，更大的问题通常来自数据量、数据复杂性、以及数据的变更速度。

数据密集型用用通常由标准组件构建而成，标准组件提供了很多通用功能

- 存储数据，以便自己或其他应用程序之后能再次找到（数据库，database）
- 记住开销昂贵操作的结果，加快读取速度（缓存，cache ）
- 允许用户按关键字搜索数据，或以各种方式对数据进行过滤（搜索索引，search indexes ）
- 向其他进程发送消息，进行异步处理（流处理，stream processing ）
- 定期处理累积的大批量数据（批处理，batch processing） 

## 可靠性

系统在困境（adversity） （硬件故障、软件故障、人为错误） 中仍可正常工作（正确完成功能，并能达到期望的性能水准） 。

 造成错误的原因叫做故障（fault） ，能预料并应对故障的系统特性可称为容错（fault-tolerant） 或韧性（resilient） 。在讨论容错时，只有谈论特定类型的错误才有意义。

故障通常定义为系统的一部分状态偏离其标准，而失效则是系统作为一个整体停止向用户提供服务。故障的概率不可能降到零，因此最好设计容错机制以防因故障而导致失效。

可恢复的故障种类

- 硬件故障
- 软件错误
- 人为错误

## 可扩展性

可扩展性（Scalability）：有合理的办法应对系统的增长（数据量、流量、复杂性）


### 描述性能

一旦系统的负载被描述好，就可以研究当负载增加会发生什么。

吞吐量（throughput） ，即每秒可以处理的记录数量，或者在特定规模数据集上运行作业的总时间。

服务的响应时间（response time） ，即客户端发送请求到接收响应之间的时间。

通常使用百分位点（percentiles） 来作为响应的指标。

 为了弄清异常值有多糟糕，可以看看更高的百分位点，例如第95、99和99.9百分位点（缩写为p95，p99和p999） 。

响应时间的高百分位点（也称为尾部延迟（tail latencies） ） 非常重要，因为它们直接影响用户的服务体验。

百分位点通常用于服务级别目标（SLO，service level objectives） 和服务级别协议（SLA，service level agreements） ，即定义服务预期性能和可用性的合同。 

排队延迟（queueing delay） 通常占了高百分位点处响应时间的很大一部分。由于服务器只能并行处理少量的事务（如受其CPU核数的限制） ，所以只要有少量缓慢的请求就能阻碍后续请求的处理，这种效应有时被称为 头部阻塞（head-of-line blocking） 。

### 应对负载的方法

纵向扩展（scaling up）：（垂直扩展（vertical scaling） ，转向更强大的机
器） 

横向扩展（scaling out）：（水平扩展（horizontal scaling） ，将负载分布到多台小机器上） 

跨多台机器分配负载也称为“无共享（shared-nothing） ”架构。可以在单台机器上运行的系统通常更简单，但高端机器可能非常贵，所以非常密集的负载通常无法避免地需要横向扩展。

 有些系统是 弹性（elastic） 的，这意味着可以在检测到负载增加时自动增加计算资源，而其他系统则是手动扩展（人工分析容量并决定向系统添加更多的机器） 。如果负载极难预测（highly unpredictable） ，则弹性系统可能很有用，但手动扩展系统更简单，并且意外操作可能会更少。

## 可维护性

许多不同的人（工程师、运维） 在不同的生命周期，都能高效地在系统上工作（使系统保持现有行为，并适应新的应用场景） 。

在设计之初就尽量考虑尽可能减少维护期间的痛苦，从而避免自己的软件系统变成遗留系统。要特别关注软件系统的三个设计原则：

- 可操作性（Operability）：便于运维团队保持系统平稳运行。
- 简单性（Simplicity）： 从系统中消除尽可能多的复杂度 ，使新工程师也能轻松理解系统。
- 可演化性（evolability）：使工程师在未来能轻松地对系统进行更改，当需求变化时为新应用场景做适配。也称为可扩展性（extensibility） ，可修改性（modifiability） 或可塑性（plasticity） 。

对于软件系统的简单性原则：用于消除额外复杂度的最好工具之一是抽象（abstraction） 。